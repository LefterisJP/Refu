#---------------------------------------------------------------------------------------#
# @author Lefteris                                                                      #
# @date 06/05/2012                                                                      #
#                                                                                       #
# This is a python script whose purpose is to parse a C file where there is a C         #
# structure defined in a specific way (using the Formatting                             #
# I am usually using in my projects) and attempts to spit out a header and source       #
# file that will contain a C++ wrapper of that very structure                           #
# To configure the input to this script open the input file which should be in the      #
# same directory as this script and by reading the comments of each input configure     #
# it properly.                                                                          #
# The name of the input file is "cppwrapper_input"                                      #
#---------------------------------------------------------------------------------------#




import sys
#import a required module to be able to move between lines
#since seek and tell don't work for me in Text files
import linecache
#import the input related class and the error functions
from rf_input import ParserInput,ParserError,printError,printWarning
#import the function related class
from rf_cfunc import CFunction, PARAMS,OPERATORS, CtorError
#import the comment parser
from rf_comments import CommentParser

#==============================Input file Parsing==============================#
#! This is the main parser class that generally holds all the input
#! and parsing variables
class Parser:
    #will keep the current line number of the input source file
    inLineN = 0;
    #will determine whether we output the progress of the parser to stdout or not
    verbose = False;
    #A boolean flag that will be set to either false or true if this is a ctor func or not
    ctor = False;
    #A boolean flag denoting whether the parser is in a #define or not
    inDefine = False;
    #! A boolean flag denoting whether a function object is currently alive inside the parser
    hasFunctionActive = False;
    #! The init function. It basically reads the input file and starts the initial parsing of the given structure's files
    #! @param userInputFileName The name of the file of the user input
    #! @param verbose determines whether we output the progress of the parser to stdout or not
    def __init__(self,userInputFileName,verbose):
        #Initialize the input object. This will hold all the user given input data
        self.inp = ParserInput(userInputFileName,verbose);
        self.verbose = verbose;
        #Open the file
        #open the desired input filename
        self.inputF = open(self.inp.inputFileName,"r");
        #open the desired output files
        self.outputH = open(self.inp.outputHFileName,"w");
        self.outputS = open(self.inp.outputSFileName,"w");
        #find the base struct and base class names.
        if(len(self.inp.ancestors) == 1 and self.inp.ancestors[0] == self.inp.structName):
            self.baseStruct = self.inp.structName;
        else:
            self.baseStruct = self.inp.ancestors[0];
        self.baseClass = self.baseStruct.partition("_")[2];

        #find the position of the struct in the input source file
        line = "something";
        while(line != ""):
            self.inLineN +=1;#update line number
            line = linecache.getline(self.inp.inputFileName,self.inLineN);
            #keep the line where a comment starts each time because if we find the struct we will need to return to it
            if(line.startswith("/**")==True):
                commentLineN = self.inLineN;
            #find where the struct is located
            if(line.find("typedef struct "+self.inp.structName)!=-1):
                if(self.verbose):
                    print("Found the required struct in the input source file!");
                #now that you found it we can go and fetch the comment
                commentLength = self.inLineN-commentLineN;
                break;
        #write the file header at the output header file
        self.outputH.write("/**\n** @author Lefteris\n");
        self.outputH.write("** This is the CPP wrapper file for the the structure "+self.inp.structName+"\n");
        self.outputH.write("** It was automatically generated by the python script gen_cppwrapper.py by reading\n");
        self.outputH.write("** the C file where the structure was located\n**/\n");
        #write include guards
        self.outputH.write("#ifndef "+self.inp.namespace.upper()+"_"+self.inp.className.upper()+"_HPP\n");
        self.outputH.write("#define "+self.inp.namespace.upper()+"_"+self.inp.className.upper()+"_HPP\n\n");
        #write include headers
        pureIFName = self.inp.inputFileName.rpartition("\\")[2];
        self.outputH.write("#include \""+pureIFName+"\"\n");
        for i in self.inp.headers:
            self.outputH.write("#include "+i+"\n");
        #open the namespace
        self.outputH.write("namespace "+self.inp.namespace+"\n{\n\n");
        #parse the comment block, writting at the same time the required comments to the header file. Also can return extra code (usually copy constructors) that will be put at the beginning of the public section of the class)
        extraCode = self.parseStructComments(commentLength,commentLineN);
        #HEADER FILE - Class declaration
        self.outputH.write("class "+self.inp.imex+" "+self.inp.className)
        #no inheritance
        print("Parent struct is \""+self.inp.parentStruct+"\"");
        if(self.inp.parentStruct == ""):
            self.outputH.write("\n{\npublic:\n");
        #inherits someting
        else:
            self.outputH.write(": public "+self.inp.parentStruct.partition("_")[2]+"\n{\npublic:\n");

        #HEADER FILE - write any given extra code
        for i in extraCode:
            self.outputH.write(i);
        if(len(extraCode) == 0):
            printError("CODE INITIALIZATION ERROR","You should provide at least a default constructor that initializes an object of the class to some default value in the extra code segment");

        #HEADER FILE - If this is a base class, promote all the inherited classes to friend classs status. This is the only way apart from making the CHandle public for inherited classes to be able to use it
        #from withint their function code when referring to cousin or parent's CHandle
        if(self.inp.isInherited == True and len(self.inp.ancestors) == 1):
            self.outputH.write("\t//This is a base class so we are declaring inherited classes as friends because we need to enable access of the CHandle to all children classes\n");
            for childStruct in self.inp.children:
                self.outputH.write("\tfriend class "+childStruct.partition("_")[2]+";\n");
        self.outputH.write("\n");

        #HEADER FILE - Constructors, copy constructors
        for i, ancStructName in enumerate(self.inp.ancestors):
            #constructor from struct pointer
            self.outputH.write("\t//! This is a constructor from a pointer of C structure type "+ancStructName+"\n");
            self.outputH.write("\t//! @param ptr A pointer to a struct of type "+ancStructName+"\n");
            self.outputH.write("\t"+self.inp.className+"("+ancStructName+"* ptr);\n")
            #copy constructor for class type of this ancestor
            ancClassName = ancStructName.partition("_")[2];
            self.outputH.write("\t//! This is a copy constructor from class type of "+ancClassName+"\n");
            self.outputH.write("\t//! @param obj A const reference to an object of class "+ancClassName+"\n");
            self.outputH.write("\t"+self.inp.className+"(const "+ancClassName+"& obj);\n");
            #assignment operator overloading for class type of this ancestor
            self.outputH.write("\t//! Overloarding the assignment operator for assigning from objects of class "+ancClassName+"\n");
            self.outputH.write("\t//! @param obj A const reference to an object of class "+ancClassName+"\n");
            self.outputH.write("\t"+self.inp.className+"& operator=(const "+ancClassName+"& obj);\n");

        #write the declaration of the  destructor
        if(self.inp.isInherited == True):
            self.outputH.write("\t//destructor\n\tvirtual ~"+self.inp.className+"();\n");
        else:
            self.outputH.write("\t//destructor\n\t~"+self.inp.className+"();\n");

        #SOURCE FILE
        #get pure output file name and include header file and stdlib.h (for the free() function)
        pureOutputName = self.inp.outputHFileName.rpartition("\\")[2];
        self.outputS.write("#include \""+pureOutputName+"\"\n");
        self.outputS.write("#include <stdlib.h>\n\n");
        #open the namespace
        self.outputS.write("namespace "+self.inp.namespace+"\n{\n\n");

        #SOURCE FILE - Definition of constructors - copy constructors
        for i, ancStructName in enumerate(self.inp.ancestors):
            ancClassName = ancStructName.partition("_")[2];

            #constructor from struct pointer
            self.outputS.write(self.inp.className+"::"+self.inp.className+"("+ancStructName+"* ptr)\n{\n");
            #if this is for a pointer of the same struct
            if(ancStructName == self.inp.structName):
                self.outputS.write("\tthis->i_"+self.baseClass+"CHandle = "+self.inp.searchFuncSig+"Copy_OUT(ptr);\n}\n\n");
            #if it's a poitner to a struct somewhere in the ancestor chain, there a function of the type searchFuncSig_From_AncStructName_OUT() should exist
            else:
                self.outputS.write("\tthis->i_"+self.baseClass+"CHandle = "+self.inp.searchFuncSig+"From"+ancClassName+"_OUT(ptr);\n}\n\n");


            #copy constructor for class type of this ancestor
            self.outputS.write(self.inp.className+"::"+self.inp.className+"(const "+ancClassName+"& obj)\n{\n");
            #if this is for an object of the same class
            if(ancStructName == self.inp.structName):
                self.outputS.write("\tthis->i_"+self.baseClass+"CHandle = "+self.inp.searchFuncSig+"Copy_OUT(("+ancStructName+"*)obj.i_"+self.baseClass+"CHandle);\n}\n\n");
            #if it's a poitner to a struct somewhere in the ancestor chain, there a function of the type searchFuncSig_From_AncStructName_OUT() should exist
            else:
                self.outputS.write("\tthis->i_"+self.baseClass+"CHandle = "+self.inp.searchFuncSig+"From"+ancClassName+"_OUT(("+ancStructName+"*)obj.i_"+self.baseClass+"CHandle);\n}\n\n");

            #assignment operator overloading for class type of this ancestor
            self.outputS.write(self.inp.className+"&"+self.inp.className+"::operator=(const "+ancClassName+"& obj)\n{\n");
            self.outputS.write("\t//self assignment check\n\tif(this != &obj){\n")
            self.outputS.write("\t\t//destroy the previous "+self.inp.className+" pointer. There will always be something as long as in the default constructor we do initialize something! (So make sure to do it yourself, default ctor is not generate automatically)\n");
            self.outputS.write("\t\t"+self.inp.searchFuncSig+"Destroy(("+self.inp.structName+"*)this->i_"+self.baseClass+"CHandle);\n");
            #if this is for an object of the same class
            if(ancStructName == self.inp.structName):
                self.outputS.write("\t\tthis->i_"+self.baseClass+"CHandle = "+self.inp.searchFuncSig+"Copy_OUT(("+ancStructName+"*)obj.i_"+self.baseClass+"CHandle);\n");
            #if it's a poitner to a struct somewhere in the ancestor chain, there a function of the type searchFuncSig_From_AncStructName_OUT() should exist
            else:
                self.outputS.write("\t\tthis->i_"+self.baseClass+"CHandle = "+self.inp.searchFuncSig+"From"+ancClassName+"_OUT(("+ancStructName+"*)obj.i_"+self.baseClass+"CHandle);\n");
            self.outputS.write("\t}\nreturn *this;\n}\n\n");

        #write the definition of the destructor
        self.outputS.write(self.inp.className+"::~"+self.inp.className+"()\n{\n\t"+self.inp.searchFuncSig+"Destroy(("+self.inp.structName+"*)this->i_"+self.baseClass+"CHandle);\n}\n");

    #! A function that parses the comments of the wrappable structure. Writes all the comments to the header file of the C++ wrapper
    #! and also returns a list of string lines that can contain extra code to be added right after the public:
    #! section of the class. Usually the user will make his own copy constructor and Constructor by reading from a Struct* like that
    def parseStructComments(self,commentLength,commentLineN):
        #loop for every line of the comment
        extraCode = [];
        inExtraCode = False;
        for i in range(0,commentLength):
            line = linecache.getline(self.inp.inputFileName,commentLineN+i);
            if(inExtraCode == False):
                #if we find information about extra CPP code
                if(line.find("@cppcode")!= -1):
                    inExtraCode = True;
                #else just copy the line
                else:
                    self.outputH.write(line);
            #we are in the extra Code section. Add it to the return string unless we get out of the extra code part
            else:
                if(line.find("@endcpp")!=-1):
                    inExtraCode = False;
                    continue;
                extraCode.append(line.lstrip('**'));

        return extraCode;

    #! Parses the input file and takes it to a specific function returning a list with
    #! @param targetName The name of the function we want to parse until. If it is an empty string then we parse until the next legal wrappable function
    #! @param startLine. Here provide:
    #!                  <ul><li>0 to start searching from the current line. Is the default</li>
    #!                  <li>-1 to start searching from the start of the file</li>
    #!                  <li>A positive number, to start searching from that line</li>
    #! @param printComments A flag denoting if the function should print grouping comments and other miscelaneous comments as it encounters them or not. Default is True
    def findFunction(self,targetName,startLine=0,printcomments=True):
        if(startLine == -1):
            self.inLineN = 0;
        elif(startLine != 0):
            self.inLineN = startLine;
        #will remember if a comment block starts with cstyle /* comment
        cStyleComment = False;
        #flag to remember if we are still in a comment block or not
        inCommentBlock = False;
        #loop until you find a correct function declaration
        line = "something";
        while(line != ""):
            self.inLineN +=1;#update line number
            line = linecache.getline(self.inp.inputFileName,self.inLineN);
            #keep the line of the start of a comment block before a function
            if(self.inDefine == False):
                if(inCommentBlock == False):
                    if(line.startswith("//!")==True or line.startswith("///")==True):
                        commentLineN = self.inLineN;
                        inCommentBlock = True;
                        #print("In line "+str(self.inLineN)+" and this is the start of a comment block\n");
                    if(line.startswith("/**")==True):
                        cStyleComment = True;
                        commentLineN = self.inLineN;
                        inCommentBlock = True;
                        #print("In line "+str(self.inLineN)+" and this is the start of a C Style comment block\n");
                else:#if we are in a comment block
                    if(cStyleComment == True):
                        if(line.find("*/") != -1):
                            inCommentBlock=False;#get out
                            cStyleComment = False;
                            #print("In line "+str(self.inLineN)+" and we got out of a C Style comment block that started at line "+str(commentLineN)+"\n");
                    else:
                        if(line.startswith("//") == False and line.startswith("/*")==False and line.startswith("**")==False):
                            inCommentBlock=False;#getout
                            #print("In line "+str(self.inLineN)+" and we got out of a comment block\n");
            #if we print relevants comment found
            if(printcomments == True):
                #make sure to print them. For now it's only the grouping doxygen comments
                spaceless = line.replace(" ","");
                spaceless = spaceless.rstrip('\n');
                if(spaceless== "//!@}" or spaceless == "//!@{"):
                    self.outputH.write(line);
                if(line.find("@name") != -1):
                    self.outputH.write(line);

            #let's see if we are in a function declaration
            if(inCommentBlock == False and self.inDefine==False):
                #if a function is found there
                if(line.find(self.inp.searchFuncSig)!=-1):
                    #if it's not a type we ignore (_Create) or #define
                    if(line.find(self.inp.ignoreFuncSig) == -1):
                        if(line.startswith("#define ")==True):
                            self.inDefine = True;
                            if(self.verbose==True):
                                print("Got inside a #define in line "+str(self.inLineN));
                        #If this is the function we have been looking for or if we are just looking for the next wrappable function
                        if(line.find(targetName)!= -1 or targetName == ""):
                            #success
                            return commentLineN;
                        #else:#is a #define
                        #    self.inDefine=True;
                        #    if(self.verbose):
                        #        print("Got inside a #define in line "+str(self.inLineN));
            #also if we are in a define check when we get out
            if(self.inDefine==True):
                if(line.endswith("\\\n")==False):
                    self.inDefine = False;
                    if(self.verbose):
                        print("Got out of a #define in line "+str(self.inLineN));
        #got out of the loop FAILURE
        return -1;

    #! Parses the input file for either 1)a specific function or 2)the next function
    #! @param targetName The name of the function we want to parse until. If it is an empty string then we parse until the next legal wrappable function
    #! @param startLine. Here provide:
    #!                  <ul><li>0 to start searching from the current line. Is the default</li>
    #!                  <li>-1 to start searching from the start of the file</li>
    #!                  <li>A positive number, to start searching from that line</li>
    def parseFunction(self,targetName,startLine=0):
        #make sure that the previous function, if any, has been cleared
        if(self.hasFunctionActive == True):
            self.currentFunction.clear();
        self.hasFunctionActive = False;

        #! Get the parser to the function and fail if we can't find it
        commentLineN = self.findFunction(targetName,startLine);
        if(commentLineN == -1):
            return False;#FAILURE
        #now that we found it we can go and fetch the comment block
        commentLength = self.inLineN-commentLineN;
        line = linecache.getline(self.inp.inputFileName,self.inLineN);
        #constructor check
        self.ctor = False;
        if(line.find(self.inp.ctorFuncSig) != -1):
           self.ctor = True;
        if(self.verbose):
            print("About to parse a comment block for possible wrappable function at line "+str(self.inLineN));
        #process the comment block and if it gives the go ahead we continue with wrapping the function
        commentObj = CommentParser(self.inp.inputFileName,self.inp.structName,self.inp.className,self.ctor);
        commentList = commentObj.process(commentLineN,commentLength);
        #if the comment list has a length then we get the okay to process the function. If not just return true
        if(len(commentList) > 0):
            #now print the comments
            for i in commentList:
                self.outputH.write(i);
            #initialize the current function
            try:
                if(self.verbose):
                    print("Found a wrappable function at line "+str(self.inLineN));
                self.currentFunction = CFunction(line,self.inp.imex,self.inp.searchFuncSig,commentObj.ctor,commentObj.notctor,self.inp.structName,self.inp.className,self.inp.ancestors,self.baseStruct,self.baseClass,
                                                 commentObj.paramFlags,commentObj.returnFlags,self.inLineN,commentObj.readyCode,commentObj.virtualFunc,commentObj.operator,self.inDefine);
                self.hasFunctionActive = True;
                if(self.verbose):
                    print("Succesfully parsed and wrapped function '"+self.currentFunction.funcName+"()'");
            except CtorError:
                if(self.verbose):
                    printError("FUNCTION PARSING","During parsing, function initialization has failed. Returning false");
                self.hasFunctionActive = False;
                #clear the previous comment object
                commentObj.clear();
                return False;
            self.currentFunction.printToCPP(self.outputS,self.outputH);
            #clear the previous comment object
            commentObj.clear();
        #return success
        return True;

    #! Prints the end of the wrapper header file
    def printEnd(self):
        #if it is a parent class then it should have the handle
        if(self.inp.parentStruct == ""):
            self.outputH.write("protected:\n\tvoid* i_"+self.inp.className+"CHandle;\n");
        self.outputH.write("};");
        self.outputH.write("\n}//namespace closes\n");#namespace closes - header
        self.outputH.write("\n#endif//include guards end");
        self.outputS.write("\n}//namespace closes\n");#namespace closes - source

    #! Clears the wrapper object
    def clear(self):
        self.inp.clear();
        linecache.clearcache();
        self.inputF.close();
        self.outputS.close();
        self.outputH.close();
        if(self.hasFunctionActive == True):
            self.currentFunction.clear();




