/**
**      ==START OF REFU LICENSE==
**
** Copyright (c) 2011-2013, Karapetsas Eleftherios
** All rights reserved.
** 
** Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
**  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
**  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the distribution.
**  3. Neither the name of the Original Author of Refu nor the names of its contributors may be used to endorse or promote products derived from
** 
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
** INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
** SERVICES;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**      ==END OF REFU LICENSE==
**
**/

$IF 0
/*
 * This file is a TEMPLATE. It does not actually get compiled at all
 * anywhere inside the library. Depending on the options you provide
 * in scons though various specializations of this file will get
 * generated during building the library
 */
$ENDIF 

/*------------- Corrensponding Header inclusion -------------*/
#include <Definitions/imex.h> //for import export macro
#include <Definitions/types.h> //for fixed size data types
#include <Definitions/retcodes.h> //for error codes, bool
#include <Definitions/defarg.h> //for enabling default arguments
#include <Preprocessor/rf_tokens.h>//for the defined library tokens
$INCLUDE @DECL_H
$INCLUDE @H
/*------------- Module related inclusion -------------*/
#include "common.ph"//for the common macro definitions
/*------------- Outside Module inclusion -------------*/
//for error logging
    #include <stdio.h>//for FILE* used inside printf.h
    #include <String/string_decl.h> //for RF_String
    #include <String/common.h> //for RFS_() macro
    #include <Threads/common.h> //for rfThread_GetID()
    #include <Utils/error.h>
//for memory allocation macros
    #include <stdlib.h> //for malloc, calloc,realloc and exit()
    #include <Utils/memory.h> //for refu memory allocation

// used by the lms stuff and by other functions in this module
    #include <string.h> //for memcpy e.t.c.

//for local memory scope macros (where needed)
$IF @LMS
    #include <Definitions/threadspecific.h> //for the thread specific attribute
    #include <Utils/localmem_decl.h> // for RF_LocalMemoryStack
    #include <stdint.h> //for UINT32_MAX used in RF_ENTER_LOCAL_SCOPE() macro
    #include <Utils/localscope.h>
$ENDIF
/*------------- End of includes -------------*/

//Allocates and returns an array of objects
@DATA_STRUCT* rfDynamicArray_Create(uint32_t numElements)
{
    @DATA_STRUCT* ret;
    //allocate the new array
    RF_MALLOC(ret, sizeof(@DATA_STRUCT), NULL);
    if(! rfDynamicArray_Init(ret, numElements))
    {
        free(ret);
        return NULL;
    }
    return ret;
}
//Initialises an array of objects
bool rfDynamicArray_Init(@DATA_STRUCT* array, uint32_t numElements)
{
    //allocate the data buffer
    array->bufferCapacity = @OBJECT_SIZE * numElements;
    RF_MALLOC(array->data, array->bufferCapacity, false);
    memset(array->data, 0, @OBJECT_SIZE * numElements);
    array->size = 0;
    return true;
}

bool rfDynamicArray_Copy_IN(@DATA_STRUCT* dst, @DATA_STRUCT* src)
{
    uint32_t i;
    dst->bufferCapacity = src->bufferCapacity;
    dst->size = src->size;
    //allocate the data buffer
    RF_MALLOC(dst->data, dst->bufferCapacity, false);
    //copy each element
    for(i=0; i < dst->size; i++)
    {
        @ASSIGN(dst->data + i, src->data + i);
    }
    return true;
}

@DATA_STRUCT* rfDynamicArray_Copy_OUT(@DATA_STRUCT* src)
{
    @DATA_STRUCT* dst;
    RF_MALLOC(dst, sizeof(@DATA_STRUCT), NULL);
    if(! rfDynamicArray_Copy_IN(dst, src))
    {
        free(dst);
        return NULL;
    }

    return dst;
}

void rfDynamicArray_Destroy(@DATA_STRUCT* l)
{
    //finally just free the  whole data buffer and the list object
    free(l->data);
    free(l);
}

void rfDynamicArray_Deinit(@DATA_STRUCT* l)
{
    //finally just free the  whole data buffer
    free(l->data);
}

// Adds a new object at the end of the array
bool rfDynamicArray_Add(@DATA_STRUCT* l, @TYPEPTR object)
{
    bool ret = true;
$IF @LMS
    RF_ENTER_LOCAL_SCOPE();
$ENDIF

    //check if there is enough space in the list
    if(l->size * @OBJECT_SIZE >= l->bufferCapacity)
    {
        //if not reallocate to double capacity
        l->bufferCapacity*= RF_OPTION_DYNAMICARRAY_CAPACITY_MULTIPLIER;
        @TYPEPTR_SHALLOW testPtr = realloc(l->data, l->bufferCapacity);
        if(testPtr)
        {
            l->data = testPtr;
        }
        else
        {
            RF_ERROR("Realloc failed in adding an object to an array of "
                     "Objects during an attempt to increase buffer"
                     " capacity");
            ret = false;
            goto cleanup;
        }
    }//end of capacity increase case
    //copy the new element in to the data and increase the index

    @ASSIGN(l->data + l->size, object);
    l->size++;

  cleanup:
$IF @LMS
    RF_EXIT_LOCAL_SCOPE();
$ENDIF
    return ret;
}

// Returns an object from the array
@TYPEPTR rfDynamicArray_Get(
    @DATA_STRUCT* l,
    uint32_t i,
    bool* code)
{
    //if the index goes over the buffer capacity
    if( i >= l->size)
    {
        *code = false;
        return 0;
    }

    *code = true;
    return @SHALLOW_PTR_ARITHMETIC(l->data + i);
}

bool rfDynamicArray_Set(
    @DATA_STRUCT* l,
    uint32_t i,
    @TYPEPTR e)
{
    bool ret = true;
$IF @LMS
    RF_ENTER_LOCAL_SCOPE();
$ENDIF

    //if the index points to a non-yet set element
    if(i >= l->size)
    {
        ret = false;
        goto cleanup;
    }

    @ASSIGN(l->data + i, e);

  cleanup:
$IF @LMS
    RF_EXIT_LOCAL_SCOPE();
$ENDIF
    return ret;
}

bool rfDynamicArray_Remove(@DATA_STRUCT* l, uint32_t i)
{
    //if the index points to a non-yet set element
    if(i >= l->size)
    {
        RF_ERROR("Attempted to remove an element from an array with an"
                 " index out of bounds");
        return false;
    }
    //Move the whole buffer back to cover up for the removed element
    memmove( @SHALLOW_PTR_ARITHMETIC(l->data + i) ,
             @SHALLOW_PTR_ARITHMETIC(l->data + i)  + 
             @SHALLOW_PTR_ARITHMETIC(1),
             @OBJECT_SIZE * (l->size - i -1));
    //and reduce size
    l->size--;

    //also check if we can reallocate downwards. Condition is if the 
    //current size is less than the fraction of the capacity
    if( l->size * @OBJECT_SIZE < 
        l->bufferCapacity/RF_OPTION_DYNAMICARRAY_CAPACITY_MULTIPLIER)
    {
        l->bufferCapacity /= RF_OPTION_DYNAMICARRAY_CAPACITY_MULTIPLIER;
        //reallocate
        @TYPEPTR_SHALLOW testPtr = realloc(l->data,l->bufferCapacity);
        if(testPtr)
            l->data = testPtr;
        else
        {
            RF_ERROR("Realloc failed in removing an object from an array"
                     " during an attempt to shrink the buffer. Aborting "
                     "program");
           return false;
        }
    }
    return true;
}

