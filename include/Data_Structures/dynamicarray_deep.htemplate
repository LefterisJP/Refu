/**
**      ==START OF REFU LICENSE==
**
** Copyright (c) 2011-2013, Karapetsas Eleftherios
** All rights reserved.
** 
** Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
**  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
**  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the distribution.
**  3. Neither the name of the Original Author of Refu nor the names of its contributors may be used to endorse or promote products derived from
** 
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
** INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
** SERVICES;LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**      ==END OF REFU LICENSE==
**
**
** --Data_Structures/dynamicarray.h
** This header declares functions to operate on a Dynamic Array
**
---------------------For internal library include make sure to have----------------------------
#include <Definitions/imex.h> //for import export macro
#include <Definitions/types.h> //for fixed size data types
#include <Definitions/retcodes.h> //for error codes, bool
#include <Definitions/defarg.h> //for enabling default arguments
#include <Preprocessor/rf_tokens.h>//for the defined library tokens
#include <Data_Structures/dynamicarray_decl.h>
#include <Data_Structures/dynamicarray.h>
---------------------For internal library include make sure to have----------------------------
*/

$IF 0
/*
 * This file is a generic TEMPLATE. Depending on the options you provide
 * in scons though various specializations of this file will get
 * generated during building the library. If you want to use the actual file
 * as it is in its generic mode then you have to provide the "generic" 
 * argument inside the data structure's specialization argument during build
 */
$ENDIF

#ifndef RF_DYNAMICARRAY_H
#define RF_DYNAMICARRAY_H

#ifdef __cplusplus
extern "C"
{///opening bracket for calling from C++
#endif

/**
 ** @brief Allocates and returns a dynamic array
 **
 ** @return The allocated array
 **/
i_DECLIMEX_ @DATA_STRUCT*  rfDynamicArray_Create(uint32_t numElements);
 

/**
 ** @brief Initializes a dynamic array
 **
 ** @param array The array to initialize
 ** @return true in case of succesfull initialization and false otherwise
 **/
i_DECLIMEX_ bool rfDynamicArray_Init(@DATA_STRUCT* array,
                                      uint32_t numElements);

/**
 ** @brief Copies @DATA_STRUCT @c src into @DATA_STRUCT @c dst
 **
 ** @param dst The new array copy to create
 ** @param src The array to copy from
 ** @return Returns @c true in succesfull copying and false otherwise
 **/
i_DECLIMEX_ bool rfDynamicArray_Copy_IN(@DATA_STRUCT* dst,
                                        @DATA_STRUCT* src);
/**
 ** @brief Creates and returns an allocated copy of the given 
 ** @DATA_STRUCT
 **
 ** @param src The array to copy from
 ** @return An allocated @DATA_STRUCT copy of the given array
 **
 **/
i_DECLIMEX_ @DATA_STRUCT* rfDynamicArray_Copy_OUT(@DATA_STRUCT* src);

/**
 ** @brief Destroys an array of objects releasing their memory and calling
 ** the destructing function if it exists
 **
 ** @param l The array to destroy
 **
 **/
i_DECLIMEX_ void rfDynamicArray_Destroy(@DATA_STRUCT* l);

/**
 ** @brief Deinitializes a array of objects releasing their memory and 
 ** calling the destructing function if it exists
 **
 ** @param l The array to deinitialize
 **
 **/
i_DECLIMEX_ void rfDynamicArray_Deinit(@DATA_STRUCT* l);

/**
 ** @brief Adds a new object to the array
 **
 ** The @c object is added in the array right after the last element and
 **  if it does not fit in the buffer, a reallocation happens.
 ** @param l The array in which to add the object
 ** @param object The object to add.
 **
 ** @return Returns @c true for success and @c false otherwise
 **/
i_DECLIMEX_ bool rfDynamicArray_Add(@DATA_STRUCT* l, @TYPEPTR object);


/**
 ** @brief Retrieves an object from the array
 **
 ** The object will be placed in the passed parameter @c ret. It must
 ** be a reference of the appropriate type.
 ** @param l The array from which to retrieve
 ** @param i The index of the element to retrieve
 ** @param ret A pointer to the object you need to populate with the
 ** retrieved data
 ** @return @c true if the object was retrieved succesfully and 
 ** @c false if the index is out of bounds
 **
 **/
i_DECLIMEX_ bool rfDynamicArray_Get_IN(
    @DATA_STRUCT* l,
    uint32_t i,
    @TYPEPTR ret
);

/**
 ** @brief Returns a pointer to an object of the array
 **
 ** @param l The array from which to retrieve
 ** @param i The index of the element to retrieve
 ** @param ret_code Is @c true if all went ok with the object retrieval
 ** and @c false if there was an index out of bounds
 ** @return the value of the array at @c i. 
 ** If there is a failure this will return @c NULL
 **/
i_DECLIMEX_ @TYPEPTR rfDynamicArray_Get_OUT(
    @DATA_STRUCT* l,
    uint32_t i,
    bool* ret_code
);

/**
 ** @brief Sets a copy of the given object to the specified array index
 **
 ** @c object is copied into the @c i index of the array. Its previous
 ** object is freed.
 ** @param l The array for which to set the object
 ** @param i The index of the object to set
 ** @param e A pointer to the object to add.
 ** previous object at @c i or @c false if you don't
 ** @return True if the element got set succesfully and false if this 
 ** is a yet unset index
 **/
i_DECLIMEX_ bool rfDynamicArray_Set(
    @DATA_STRUCT* l,
    uint32_t i,
    @TYPEPTR e
);

/**
 ** @brief Removes an object from the array.
 **
 ** All objects get moved to make up for the freed up space and if there
 ** is too much space left the array gets reallocated downwards.
 ** Also the destructor of the object at index @c i is called if given.
 ** @param l The array from which to remove
 ** @param i The index of the element to remove
 ** @return Returns true if the object at @c i was succesfully removed
 ** and @c false if there is no element at @c i or there was another error
 **/
i_DECLIMEX_ bool rfDynamicArray_Remove(@DATA_STRUCT* l, uint32_t i);

#ifdef __cplusplus
}///closing bracket for calling from C++
#endif


#endif //end of include guards
